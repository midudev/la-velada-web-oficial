---
/* 
  Propiedades del componente y tipado. 
  Se reciben: id, nombre y clase extra (extraClass)
*/
const { id, name, class: extraClass } = Astro.props;

interface Props {
  id: string;
  name: string;
  class: string;
}
---

<!-- Tarjeta del boxeador -->
<a
  class={`boxer-card ${extraClass} inline-block transition-all w-10 sm:w-14 md:w-16 lg:w-24 xl:w-26 group relative rounded-lg duration-300 hover:scale-110 hover:shadow-lg hover:z-20`}
  href={`/luchador/${id}`}
  data-id={id}
>
  <div class="relative overflow-hidden rounded-lg">
    <!-- Sprite del luchador -->
    <div 
      class="fighter-sprite aspect-[900/1200] h-full w-full bg-gradient-to-t from-gray-50/40 via-gray-50/20 via-40 to-transparent transition-transform duration-500 group-hover:scale-110"
      data-fighter={id}
      role="img"
      aria-label={`Tarjeta del boxeador ${name}`}
    ></div>

    <!-- Efecto de barrido -->
    <div 
      class="absolute inset-0 -translate-x-full bg-gradient-to-tr from-transparent via-white/20 to-transparent transition-transform duration-700 ease-in-out group-hover:translate-x-full">
    </div>

    <!-- Borde animado -->
    <div 
      class="border-theme-tickle-me-pink/70 absolute inset-0 rounded-lg border-0 opacity-0 transition-all duration-300 group-hover:border-2 group-hover:opacity-100">
    </div>
  </div>

  <!-- Detalle textual, aparece al interactuar -->
  <div 
    class="absolute inset-0 flex translate-y-2 flex-col items-center justify-end rounded-lg bg-gradient-to-t from-pink-950/90 via-pink-950/40 to-transparent p-2 opacity-0 transition-all duration-300 group-hover:translate-y-0 group-hover:opacity-100">
    <h3 
      class="text-theme-tickle-me-pink text-xs font-semibold tracking-wide uppercase drop-shadow-[0_1px_2px_rgba(0,0,0,0.8)]"
    >
      {name}
    </h3>
  </div>

  <!-- Barra inferior animada -->
  <div 
    class="bg-theme-tickle-me-pink absolute -bottom-1 left-1/2 h-1 w-0 -translate-x-1/2 transform rounded-t-md transition-all duration-300 group-hover:w-2/3"
  >
  </div>
</a>

<style>
  /* Estilos para efectos de inclinación */
  .boxer-left {
    /* clip-path: polygon(0% 0%, 95% 0%, 100% 100%, 5% 100%); */
    transform: skew(2deg);
  }
  .boxer-right {
    /* clip-path: polygon(5% 0%, 100% 0%, 95% 100%, 0% 100%); */
    transform: skew(-2deg);
  }
  
  /* Sprite de luchadores, usando una imagen única */
  .fighter-sprite {
    background-image: url('/images/fighters/cards/fighters-sheet.webp');
    background-repeat: no-repeat;
    background-size: 1400% 100%; /* 14 imágenes en una fila */
    position: relative;
    background-position: calc(var(--fighter-index, 0) / 13 * 100%) 0;
  }

  /* Estilo para cuando el sprite falla y usamos imagen individual */
  .sprite-error {
    background-image: var(--fallback-url) !important;
    background-size: cover !important;
    background-position: center !important;
  }

  /* Definir índices para cada luchador */
  .fighter-sprite[data-fighter="abby"] { --fighter-index: 0; }
  .fighter-sprite[data-fighter="alana"] { --fighter-index: 1; }
  .fighter-sprite[data-fighter="andoni"] { --fighter-index: 2; }
  .fighter-sprite[data-fighter="arigeli"] { --fighter-index: 3; }
  .fighter-sprite[data-fighter="carlos"] { --fighter-index: 4; }
  .fighter-sprite[data-fighter="gaspi"] { --fighter-index: 5; }
  .fighter-sprite[data-fighter="grefg"] { --fighter-index: 6; }
  .fighter-sprite[data-fighter="peereira"] { --fighter-index: 7; }
  .fighter-sprite[data-fighter="perxitaa"] { --fighter-index: 8; }
  .fighter-sprite[data-fighter="rivaldios"] { --fighter-index: 9; }
  .fighter-sprite[data-fighter="roro"] { --fighter-index: 10; }
  .fighter-sprite[data-fighter="tomas"] { --fighter-index: 11; }
  .fighter-sprite[data-fighter="viruzz"] { --fighter-index: 12; }
  .fighter-sprite[data-fighter="westcol"] { --fighter-index: 13; }

  @media (prefers-reduced-motion) {
    .boxer-card,
    .boxer-card:hover,
    .boxer-card img,
    .boxer-card div {
      transition: opacity 0.3s ease !important;
      transform: none !important;
    }
  }

  /* Animaciones para el borde seleccionado */
  @keyframes pulseBorder {
    0% {
      box-shadow: 0 0 0 0 rgba(255, 20, 147, 0.7);
    }
    70% {
      box-shadow: 0 0 0 10px rgba(255, 20, 147, 0);
    }
    100% {
      box-shadow: 0 0 0 0 rgba(255, 20, 147, 0);
    }
  }
  @keyframes selectedPulse {
    0% {
      box-shadow:
        0 0 0 0 rgba(255, 20, 147, 0.7),
        inset 0 0 0 2px rgba(255, 20, 147, 1);
    }
    70% {
      box-shadow:
        0 0 0 15px rgba(255, 20, 147, 0),
        inset 0 0 0 2px rgba(255, 20, 147, 1);
    }
    100% {
      box-shadow:
        0 0 0 0 rgba(255, 20, 147, 0),
        inset 0 0 0 2px rgba(255, 20, 147, 1);
    }
  }
  .boxer-card.selected {
    animation: selectedPulse 2s infinite cubic-bezier(0.66, 0, 0, 1);
  }
  @media (prefers-reduced-motion) {
    .boxer-card.selected {
      animation: none;
      box-shadow: inset 0 0 0 2px rgba(255, 20, 147, 1);
    }
  }
</style>

<script>
  import { FIGHTERS } from '@/consts/fighters';

  // Tipos
  type FighterId = typeof FIGHTERS[number]['id'];
  
  // Constantes y config
  const CONFIG = {
    classes: {
      selected: 'selected',
      spriteError: 'sprite-error',
      grayscale: 'grayscale-100',
      opacity: 'opacity-40',
    },
    timing: {
      hoverExitDelay: 500,
      clickDelay: 600,
      particleThrottle: 300, // Evitar crear partículas demasiado seguido
    },
    particles: {
      count: 10,
      duration: 1000,
      baseRadius: 50,
      varianceRadius: 20,
    },
    selectors: {
      card: '.boxer-card',
      sprite: '.fighter-sprite',
    },
    paths: {
      spriteSheet: '/images/fighters/cards/fighters-sheet.webp',
      fallbackTemplate: (id: string) => `/images/fighters/cards/${id}.webp`,
    },
  };

  // Mapa de oponentes precalculado (inmutable)
  const versusMap = Object.freeze(
    new Map(FIGHTERS.flatMap(fighter => 
      fighter.versus ? [[fighter.id, fighter.versus], [fighter.versus, fighter.id]] : [],
  )),
);
  
  // Estado global (minimizado)
  const state = {
    lastParticleTime: 0,
    hoverTimeoutId: null as number | null,
  };

  // Crea partículas con DocumentFragment (optimizado)
  function createParticles(element: HTMLElement): void {
    // Throttle: limitar creación de partículas (mejor rendimiento)
    const now = Date.now();
    if (now - state.lastParticleTime < CONFIG.timing.particleThrottle) return;
    state.lastParticleTime = now;
    
    const fragment = document.createDocumentFragment();
    const { count, duration, baseRadius, varianceRadius } = CONFIG.particles;
    
    // Crear partículas con un solo bucle y minimizar reflows
    for (let i = 0; i < count; i++) {
      const particle = document.createElement('div');
      particle.className = 'absolute w-1 h-1 bg-theme-tickle-me-pink rounded-full';
      
      const angle = Math.random() * Math.PI * 2;
      const radius = baseRadius + Math.random() * varianceRadius;
      
      // Establecer estilos de una vez
      particle.style.cssText = `
        left: ${50 + Math.cos(angle) * radius}%;
        top: ${50 + Math.sin(angle) * radius}%;
        pointer-events: none;
      `;
      
      // Animar y limpiar
      particle.animate(
        [
          { opacity: 1, transform: 'scale(1)' },
          { opacity: 0, transform: 'scale(0)' },
        ],
        { duration, easing: 'ease-out', fill: 'forwards' },
    ).onfinish = () => particle.remove();
      
      fragment.appendChild(particle);
    }
    
    // Una sola operación DOM para todas las partículas
    element.appendChild(fragment);
  }

  // Inicializa fallback para sprite sheet
  function initSpriteFallback(): void {
    const spriteSheet = new Image();
    
    // Solo manejar error - no hacer nada si carga correctamente
    spriteSheet.onerror = () => {
      // Usar selector específico para mejor rendimiento
      document.querySelectorAll<HTMLElement>(CONFIG.selectors.sprite).forEach(sprite => {
        const id = sprite.dataset.fighter;
        if (!id) return;
        
        // Aplicar fallback
        sprite.classList.add(CONFIG.classes.spriteError);
        sprite.style.setProperty(
          '--fallback-url',
          `url('${CONFIG.paths.fallbackTemplate(id)}')`,
      );
      });
    };
    
    // Cargar sprite
    spriteSheet.src = CONFIG.paths.spriteSheet;
  }

  // Actualizar estilos de tarjetas (función optimizada)
  function updateCardStyles(cards: HTMLElement[], currentId: FighterId | null, opponentId?: FighterId): void {
    // Batch actualizaciones
    window.requestAnimationFrame(() => {
      cards.forEach(card => {
        const cardId = card.dataset.id;
        const isRelevant = !currentId || cardId === currentId || cardId === opponentId;
        // Toggle optimizado
        card.classList.toggle(CONFIG.classes.grayscale, !isRelevant);
        card.classList.toggle(CONFIG.classes.opacity, !isRelevant);
      });
    });
  }

  // Inicializar cuando Astro carga la página
  document.addEventListener('astro:page-load', () => {
    initSpriteFallback();
    
    // Una sola consulta DOM para todas las tarjetas
    const allCards = Array.from(document.querySelectorAll<HTMLElement>(CONFIG.selectors.card));
    
    // Manejadores de eventos optimizados
    allCards.forEach(card => {
      const id = card.dataset.id as FighterId;
      if (!id) return;
      
      const opponentId = versusMap.get(id);
      
      // Handlers optimizados con opciones passive donde sea posible
      const handleEnter = () => {
        state.hoverTimeoutId && clearTimeout(state.hoverTimeoutId);
        state.hoverTimeoutId = null;
        
        // Dispatch event solo si necesario
        document.dispatchEvent(new CustomEvent('boxer-card-hovered', { detail: { id } }));
        updateCardStyles(allCards, id, opponentId);
        createParticles(card);
      };
      
      const handleLeave = () => {
        state.hoverTimeoutId = window.setTimeout(() => {
          document.dispatchEvent(new CustomEvent('boxer-card-exit'));
          updateCardStyles(allCards, null);
        }, CONFIG.timing.hoverExitDelay);
      };
      
      const handleClick = (e: MouseEvent) => {
        e.preventDefault();
        
        // Batch las operaciones DOM juntas
        window.requestAnimationFrame(() => {
          allCards.forEach(c => c.classList.remove(CONFIG.classes.selected));
          card.classList.add(CONFIG.classes.selected);
        });
        
        createParticles(card);
        
        const href = card.getAttribute('href');
        if (href) {
          setTimeout(() => {
            window.location.href = href;
          }, CONFIG.timing.clickDelay);
        }
      };
      
      // Añadir listeners con passive donde sea posible (mejor scrolling)
      card.addEventListener('mouseenter', handleEnter, { passive: true });
      card.addEventListener('focusin', handleEnter, { passive: true });
      card.addEventListener('mouseleave', handleLeave, { passive: true });
      card.addEventListener('focusout', handleLeave, { passive: true });
      card.addEventListener('click', handleClick); // No puede ser passive
    });
  });
</script>
