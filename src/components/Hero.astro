---
import { FIGHTERS, MATCHUPS } from '@/consts/fighters';
import BoxerCard from './BoxerCard.astro';

const firstRow = FIGHTERS.slice(0, 6);
const leftRow = firstRow.slice(0, 3);
const rightRow = firstRow.slice(3);

const secondRow = FIGHTERS.slice(6);
const leftSecondRow = secondRow.slice(0, 4);
const rightSecondRow = secondRow.slice(4, 8);

const opponentMap = new Map<string, string>();
MATCHUPS.forEach(matchup => {
  opponentMap.set(matchup.fighter1, matchup.fighter2);
  opponentMap.set(matchup.fighter2, matchup.fighter1);
});

const animationDelay = [500, 700, 800];
const reverseDelay = [...animationDelay].reverse();
const animationDelaySecondRow = [...animationDelay, 900];
const reverseDelaySecondRow = [...animationDelaySecondRow].reverse();

const visibleFighters = FIGHTERS;
---

<section class="relative flex min-h-screen w-full overflow-hidden">
  <div
    class="mask-fade-bottom animate-fade-in absolute inset-0 z-0 w-full bg-[url('/images/hero.avif')] bg-cover bg-center duration-75"
  >
  </div>

  <div class="mask-fade-bottom absolute inset-0 z-[1] w-full bg-black opacity-10"></div>

  <div class="relative z-[2] flex w-full flex-col items-center p-8 text-center">

    <div id="landing" class="absolute top-0 flex w-full flex-col items-center py-16 transition-opacity duration-500">
      <h3
        class="text-theme-seashell animate-fade-in animate-delay-300 tracking mt-4 font-medium leading-[100%]"
      >
        26 DE <br />JULIO
      </h3>
      <figure class="animate-fade-in relative">
        <img
          class="relative z-20 h-auto w-64 sm:w-72 md:w-80 lg:w-96"
          src="/images/logo.png"
          fetchpriority="high"
          alt="La Velada del AÃ±o V"
          decoding="async"
        />
        <div class="absolute top-0 z-0 size-64 bg-pink-400/80 blur-2xl"></div>
      </figure>

      <div class="relative z-50">
        <h3
          class="text-theme-seashell animate-fade-in animate-delay-500 z-0 mt-4 font-medium leading-relaxed tracking-wider uppercase"
        >
          Estadio<br />La Cartuja,<br />Sevilla
        </h3>
         <div class="absolute -inset-2 -z-10 h-full w-full bg-pink-400/80 blur-2xl"></div>
        <a
          href="https://twitch.tv/ibai"
          rel="noopener noreferrer"
          target="_blank"
          class="animate-fade-in animate-delay-700 z-50 mt-4 inline-block font-medium leading-relaxed tracking-wider uppercase transition hover:scale-125"
        >
          twitch.tv<br />Ibai
        </a>
      </div>
    </div>

    <div
      id="fighter-display-container"
      class="pointer-events-none absolute inset-0 z-[5] flex flex-col items-center"
    >
      <div class="relative top-96 z-1 mx-auto flex h-[4.5rem] w-full items-center justify-center">
        {
          FIGHTERS.map(({ id, name }) => (
            <img
              transition:name={`text-${id}`}
              data-id={`hero-text-${id}`}
              src={`/images/fighters/text/${id}.webp`}
              alt={name}
              decoding="async"
              class="mask-fade-text absolute hidden h-full w-auto transition-opacity duration-500"
              fetchpriority="low"
            />
          ))
        }
      </div>

      <div
        class="mask-fade-bottom relative bottom-0 mx-auto flex h-[80vh] w-full items-center justify-center"
      >
        {
          FIGHTERS.map(({ id, name }) => (
            <img
              transition:name={`image-${id}`}
              data-id={`hero-image-${id}`}
              src={`/images/fighters/big/${id}.webp`}
              alt={name}
              decoding="async"
              class="absolute hidden h-full w-full max-w-[90vw] object-contain transition-opacity duration-500 lg:max-w-[80vw]"
              fetchpriority="low"
            />
          ))
        }
      </div>
    </div>

    <div id="mobile-fighters-container" class="mobile-fighters md:hidden fixed bottom-0 left-0 right-0 w-full pb-8 pt-4 bg-gradient-to-t from-black/80 to-transparent z-50 transition-transform duration-300 ease-in-out">
      <div class="mobile-carousel-container">
        <div class="mobile-carousel" id="mobile-carousel">
          {visibleFighters.map(({ id, name }) => (
            <a class="mobile-fighter-card" data-id={id} href={`/luchador/${id}`}>
              <div class="mobile-card-inner">
                <img
                  src={`/images/fighters/cards/${id}.webp`}
                  alt={name}
                  class="mobile-fighter-img"
                  loading="lazy"
                  decoding="async"
                />
                <div class="mobile-card-overlay">
                  <h3 class="mobile-fighter-name">{name}</h3>
                </div>
              </div>
            </a>
          ))}
        </div>
      </div>
    </div>

    <div id="desktop-fighters-container" class="desktop-fighters hidden md:flex relative h-full w-full max-w-6xl flex-col items-center justify-end gap-8 p-8 z-10">
      <div class="flex w-full flex-wrap justify-between px-4">
        <div class="flex flex-wrap justify-start gap-4">
          {leftRow.map(({ id, name }, index) => (
            <div class="boxer-card-wrapper" data-fighter-id={id} data-opponent-id={opponentMap.get(id)}>
              <div class={`animate-fade-in-right animate-duration-slower animate-delay-${animationDelay[index]}`}>
                <BoxerCard id={id} name={name} class="boxer-left" />
              </div>
            </div>
          ))}
        </div>
        <div class="flex flex-wrap justify-end gap-4">
          {rightRow.map(({ id, name }, index) => (
            <div class="boxer-card-wrapper" data-fighter-id={id} data-opponent-id={opponentMap.get(id)}>
              <div class={`animate-fade-in-left animate-duration-slower animate-delay-${reverseDelay[index]}`}>
                <BoxerCard id={id} name={name} class="boxer-right" />
              </div>
            </div>
          ))}
        </div>
      </div>
      <div class="flex w-full flex-wrap justify-between gap-4 px-4">
        <div class="flex flex-wrap justify-start gap-4">
          {leftSecondRow.map(({ id, name }, index) => (
            <div class="boxer-card-wrapper" data-fighter-id={id} data-opponent-id={opponentMap.get(id)}>
              <div class={`animate-fade-in-up animate-delay-${animationDelaySecondRow[index]}`}>
                <BoxerCard id={id} name={name} class="boxer-left" />
              </div>
            </div>
          ))}
        </div>
        <div class="flex flex-wrap justify-end gap-4">
          {rightSecondRow.map(({ id, name }, index) => (
            <div class="boxer-card-wrapper" data-fighter-id={id} data-opponent-id={opponentMap.get(id)}>
              <div class={`animate-fade-in-up animate-delay-${reverseDelaySecondRow[index]}`}>
                <BoxerCard id={id} name={name} class="boxer-right" />
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>

  </div>
</section>

<style>
  .mask-fade-text {
    mask-image: linear-gradient(to bottom, transparent 5%, black 6%, black 95%, transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom, transparent 5%, black 6%, black 95%, transparent 100%);
  }
  .mask-fade-bottom {
    mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 70%, rgba(0,0,0,0) 100%);
     -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 70%, rgba(0,0,0,0) 100%);
  }

  .mobile-fighters.hidden-by-scroll {
     transform: translateY(100%);
  }

  .mobile-carousel-container {
    width: 100%;
    height: 12rem;
    perspective: 1000px;
    z-index: 10;
    display: flex;
    justify-content: center;
    overflow: hidden;
    padding: 0 1rem;
  }
  .mobile-carousel {
    position: relative;
    width: 100%;
    height: 100%;
    transform-style: preserve-3d;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0 2rem;
  }
  .mobile-fighter-card {
    position: absolute;
    width: 6.5rem;
    height: 9rem;
    transform-origin: center;
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease;
    cursor: pointer;
    z-index: 1;
    text-decoration: none;
    backface-visibility: hidden;
    transform-style: preserve-3d;
    margin: 0 0.5rem;
    -webkit-tap-highlight-color: transparent;
  }
  .mobile-card-inner {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: 0.75rem;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    border: 2px solid rgba(255, 105, 180, 0.3);
    background: linear-gradient(145deg, rgba(255,105,180,0.1) 0%, rgba(0,255,255,0.1) 100%);
    transition: all 0.3s ease;
    transform-style: preserve-3d;
  }
  .mobile-fighter-card.active .mobile-card-inner {
    border-color: rgba(255, 255, 255, 0.8);
    box-shadow: 0 0 20px rgba(255,105,180,0.5);
  }
  .mobile-fighter-img {
    display: block;
    aspect-ratio: 900/1200;
    height: 100%;
    width: 100%;
    object-fit: cover;
    object-position: top;
    transition: transform 0.3s ease-in-out;
  }
  .mobile-fighter-card.active .mobile-fighter-img {
    transform: scale(1.05);
  }
  .mobile-card-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-end;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 10%, transparent 70%);
    opacity: 0;
    transition: opacity 0.3s ease;
    padding: 0.5rem;
  }
  .mobile-fighter-card.active .mobile-card-overlay {
    opacity: 1;
  }
  .mobile-fighter-name {
    color: #fff;
    font-size: 0.8rem;
    font-weight: 700;
    text-shadow: 0 1px 3px rgba(0,0,0,0.8);
    text-align: center;
    line-height: 1.2;
  }

  .mobile-carousel-container::after {
    content: '';
    position: absolute;
    bottom: -1rem;
    left: 50%;
    transform: translateX(-50%);
    width: 60px;
    height: 3px;
    background: linear-gradient(90deg, transparent, rgba(255,105,180,0.5), transparent);
    border-radius: 2px;
    animation: pulse 2s infinite ease-in-out;
  }
  @keyframes pulse {
    0%, 100% { opacity: 0.5; width: 80px; }
    50% { opacity: 1; width: 100px; }
  }

  .boxer-card-wrapper {
    position: relative;
    transition: all 0.3s ease;
    margin: 0;
  }
  .boxer-card-wrapper.highlight {
    transform: scale(1.02);
    z-index: 2;
    box-shadow: 0 0 15px rgba(255, 105, 180, 0.4);
    filter: none;
  }
  .boxer-card-wrapper.highlight-opponent {
    transform: scale(1.01);
    z-index: 1;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    filter: none;
  }
  .boxer-card-wrapper.desaturate {
    filter: grayscale(0.5);
    opacity: 0.6;
    transform: scale(1);
  }
</style>

<script>
  interface Fighter {
    id: string;
    name: string;
  }

  function debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {
    let timeoutId: ReturnType<typeof setTimeout> | null = null;
    return function(this: ThisParameterType<T>, ...args: Parameters<T>) {
      const context = this;
      clearTimeout(timeoutId!);
      timeoutId = setTimeout(() => {
        func.apply(context, args);
      }, wait);
    };
  }

  function heroLogic() {
    const $landing = document.getElementById('landing');
    const $fighterDisplayContainer = document.getElementById('fighter-display-container');
    const $mobileFightersContainer = document.getElementById('mobile-fighters-container');
    const $desktopFightersContainer = document.getElementById('desktop-fighters-container');
    const $carousel = document.getElementById('mobile-carousel');
    const $carouselContainer = document.querySelector('.mobile-carousel-container');
    const $fighterTextElements = document.querySelectorAll<HTMLElement>('[data-id^="hero-text-"]');
    const $fighterImageElements = document.querySelectorAll<HTMLElement>('[data-id^="hero-image-"]');
    const $desktopCardWrappers = document.querySelectorAll<HTMLElement>('.boxer-card-wrapper');
    const $mobileFighterCards = $carousel ? Array.from($carousel.querySelectorAll<HTMLElement>('.mobile-fighter-card')) : [];

    let currentFighterId: string | null = null;
    let isMobileView = window.matchMedia('(max-width: 767px)').matches;
    let mobileCarouselInitialized = false;
    let desktopListenersInitialized = false;
    let scrollListenerActive = false;

    let isDragging = false;
    let startX = 0;
    let currentX = 0;
    let rotationAngle = 0;
    let lastTouchTime = 0;
    let touchVelocity = 0;
    let inertia = 0;
    let animationFrameId: number | null = null;
    const totalCards = $mobileFighterCards.length;
    const cardAngle = totalCards > 0 ? 360 / totalCards : 0;
    const radius = 190;
    const visibleCardCount = 5;

    function normalizeAngle(angle: number): number {
      return ((angle % 360) + 360) % 360;
    }

    function getCardIndexAtAngle(angle: number): number {
      if (totalCards === 0) return 0;
      const normalized = normalizeAngle(-angle);
      return Math.round(normalized / cardAngle) % totalCards;
    }

    function showFighterDisplay(id: string | null) {
      if (id === currentFighterId) return;

      if (currentFighterId) {
        const prevText = $fighterDisplayContainer?.querySelector(`[data-id="hero-text-${currentFighterId}"]`);
        const prevImage = $fighterDisplayContainer?.querySelector(`[data-id="hero-image-${currentFighterId}"]`);
        prevText?.classList.add('opacity-0', 'hidden');
        prevImage?.classList.add('opacity-0', 'hidden');
        prevText?.classList.remove('animate-zoom-in');
        prevImage?.classList.remove('animate-slide-up-fade');
      }

      if (id) {
        $landing?.classList.add('opacity-0', 'pointer-events-none');
        const newText = $fighterDisplayContainer?.querySelector(`[data-id="hero-text-${id}"]`);
        const newImage = $fighterDisplayContainer?.querySelector(`[data-id="hero-image-${id}"]`);
        newText?.classList.remove('hidden');
        newImage?.classList.remove('hidden');
        void newText?.offsetWidth;
        void newImage?.offsetWidth;
        newText?.classList.add('animate-zoom-in');
        newImage?.classList.add('animate-slide-up-fade');
        newText?.classList.remove('opacity-0');
        newImage?.classList.remove('opacity-0');
      } else {
        $landing?.classList.remove('opacity-0', 'pointer-events-none');
      }

      currentFighterId = id;
    }

    function resetDesktopView() {
        showFighterDisplay(null);
        $desktopCardWrappers.forEach(wrapper => {
          wrapper.classList.remove('highlight', 'highlight-opponent', 'desaturate');
        });
    }

    function updateDesktopHighlights(selectedId: string | null) {
      if (!selectedId) {
        resetDesktopView();
        return;
      }

      showFighterDisplay(selectedId);

      let opponentId: string | null = null;
      $desktopCardWrappers.forEach(wrapper => {
        const fighterId = wrapper.dataset.fighterId;
        if (fighterId === selectedId) {
          wrapper.classList.remove('desaturate', 'highlight-opponent');
          wrapper.classList.add('highlight');
          opponentId = wrapper.dataset.opponentId ?? null;
        } else {
          wrapper.classList.add('desaturate');
          wrapper.classList.remove('highlight', 'highlight-opponent');
        }
      });

      if (opponentId) {
        const opponentWrapper = $desktopFightersContainer?.querySelector(`.boxer-card-wrapper[data-fighter-id="${opponentId}"]`);
        if (opponentWrapper) {
          opponentWrapper.classList.remove('desaturate', 'highlight');
          opponentWrapper.classList.add('highlight-opponent');
        }
      }

      $desktopCardWrappers.forEach(wrapper => {
        const fighterId = wrapper.dataset.fighterId;
        if (fighterId !== selectedId && fighterId !== opponentId) {
           wrapper.classList.add('desaturate');
           wrapper.classList.remove('highlight', 'highlight-opponent');
        }
      });
    }

    function positionAllMobileCards() {
      if (!$carousel || totalCards === 0) return;

      const normalizedRotation = normalizeAngle(-rotationAngle);
      const centralIndex = getCardIndexAtAngle(rotationAngle);

      $mobileFighterCards.forEach((card, index) => {
        const cardOffsetAngle = index * cardAngle;
        let relativeAngle = normalizeAngle(cardOffsetAngle - normalizedRotation);
        if (relativeAngle > 180) relativeAngle -= 360;

        const angleRad = relativeAngle * (Math.PI / 180);
        const x = Math.sin(angleRad) * radius;
        const z = (Math.cos(angleRad) * radius) - radius * 1.05;

        const frontness = Math.cos(angleRad);
        const scale = 0.7 + Math.max(0, frontness) * 0.3;
        const opacity = Math.max(0, 0.4 + frontness * 0.6);

        (card as HTMLElement).style.transform = `translateX(${x}px) translateZ(${z}px) rotateY(${-relativeAngle * 0.98}deg) scale(${scale})`;
        (card as HTMLElement).style.opacity = opacity.toString();
        (card as HTMLElement).style.zIndex = `${Math.round(100 + frontness * 10)}`;

        if (index === centralIndex) {
          if (!card.classList.contains('active')) {
            card.classList.add('active');
            const id = card.getAttribute('data-id');
            if (id) showFighterDisplay(id);
          }
        } else {
          card.classList.remove('active');
        }
      });
    }

    function snapToNearestCard() {
      if (totalCards === 0) return;

      const currentSnappedIndex = getCardIndexAtAngle(rotationAngle);
      const targetAngle = -(currentSnappedIndex * cardAngle);

      let angleDiff = targetAngle - rotationAngle;
      if (angleDiff > 180) angleDiff -= 360;
      if (angleDiff < -180) angleDiff += 360;

      const startAngle = rotationAngle;
      const startTime = performance.now();
      const duration = 300;

      function animateSnap(timestamp: number) {
        const elapsed = timestamp - startTime;
        if (elapsed < duration) {
          const progress = 1 - Math.pow(1 - elapsed / duration, 3);
          rotationAngle = startAngle + (angleDiff * progress);
          positionAllMobileCards();
          animationFrameId = requestAnimationFrame(animateSnap);
        } else {
          rotationAngle = targetAngle;
          positionAllMobileCards();
          animationFrameId = null;
        }
      }

      cancelAnimationFrame(animationFrameId!);
      animationFrameId = requestAnimationFrame(animateSnap);
    }

    function applyInertia() {
        let lastTimestamp = performance.now();

        function inertiaLoop(timestamp: number) {
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            if (Math.abs(inertia) > 0.1 && deltaTime > 0) {
                rotationAngle += inertia * (deltaTime / 16.66);
                inertia *= 0.95;
                positionAllMobileCards();
                animationFrameId = requestAnimationFrame(inertiaLoop);
            } else {
                snapToNearestCard();
                animationFrameId = null;
            }
        }
        cancelAnimationFrame(animationFrameId!);
        animationFrameId = requestAnimationFrame(inertiaLoop);
    }

    function handleTouchStart(e: TouchEvent) {
      if (totalCards === 0) return;
      isDragging = true;
      startX = e.touches[0].clientX;
      currentX = startX;
      lastTouchTime = Date.now();
      touchVelocity = 0;
      inertia = 0;
      cancelAnimationFrame(animationFrameId!);
      $carousel?.classList.add('dragging');
    }

    function handleTouchMove(e: TouchEvent) {
      if (!isDragging || totalCards === 0) return;

      const currentTouchX = e.touches[0].clientX;
      const diffX = currentTouchX - currentX;
      const now = Date.now();
      const dt = now - lastTouchTime;

      if (dt > 0) {
        const instantVelocity = diffX / dt;
        touchVelocity = touchVelocity * 0.8 + instantVelocity * 0.2;
      }

      rotationAngle -= (diffX / 3);
      currentX = currentTouchX;
      lastTouchTime = now;

      requestAnimationFrame(positionAllMobileCards);
    }

    function handleTouchEnd() {
      if (totalCards === 0) return;
      isDragging = false;
      $carousel?.classList.remove('dragging');

      const dragDistance = Math.abs(startX - currentX);
      startX = 0;

      if (dragDistance < 10 && (Date.now() - lastTouchTime) < 200) {
         snapToNearestCard();
         return;
      }


      if (Math.abs(touchVelocity) > 0.3) {
          inertia = touchVelocity * 4;
          inertia = Math.max(-15, Math.min(15, inertia));
          applyInertia();
      } else {
          snapToNearestCard();
      }
      touchVelocity = 0;
    }

    function handleMobileCardClick(e: MouseEvent, card: HTMLElement, index: number) {
        if (isDragging || Math.abs(startX - currentX) > 10) {
             e.preventDefault();
             return;
        }

        const id = card.getAttribute('data-id');
        if (id && card.classList.contains('active')) {
             window.location.href = `/luchador/${id}`;
        } else {
            e.preventDefault();
            const targetAngle = -(index * cardAngle);
            let angleDiff = targetAngle - rotationAngle;
            if (angleDiff > 180) angleDiff -= 360;
            if (angleDiff < -180) angleDiff += 360;

            const startAngle = rotationAngle;
            const startTime = performance.now();
            const duration = 300 + Math.min(300, Math.abs(angleDiff) * 1.5);

            function animateRotation(timestamp: number) {
                const elapsed = timestamp - startTime;
                if (elapsed < duration) {
                    const progress = 1 - Math.pow(1 - elapsed / duration, 3);
                    rotationAngle = startAngle + (angleDiff * progress);
                    positionAllMobileCards();
                    animationFrameId = requestAnimationFrame(animateRotation);
                } else {
                    rotationAngle = targetAngle;
                    positionAllMobileCards();
                    animationFrameId = null;
                }
            }
            cancelAnimationFrame(animationFrameId!);
            animationFrameId = requestAnimationFrame(animateRotation);
        }
    }

    function handleDesktopCardHover(event: MouseEvent) {
        const wrapper = (event.currentTarget as HTMLElement)?.closest('.boxer-card-wrapper') as HTMLElement | null;
        if (wrapper) {
            const id = wrapper.dataset.fighterId;
            if (id) {
                updateDesktopHighlights(id);
            }
        }
    }

    function handleDesktopContainerExit() {
        resetDesktopView();
    }

    const handleScroll = debounce(() => {
        if (isMobileView && $mobileFightersContainer) {
            if (window.scrollY > 100) {
                $mobileFightersContainer.classList.add('hidden-by-scroll');
            } else {
                $mobileFightersContainer.classList.remove('hidden-by-scroll');
            }
        }
    }, 50);

    function setupMobileListeners() {
        if (mobileCarouselInitialized || totalCards === 0) return;

        $carouselContainer?.addEventListener('touchstart', handleTouchStart, { passive: true });
        $carouselContainer?.addEventListener('touchmove', handleTouchMove, { passive: true });
        $carouselContainer?.addEventListener('touchend', handleTouchEnd);

        $mobileFighterCards.forEach((card, index) => {
            card.addEventListener('click', (e) => handleMobileCardClick(e, card, index));
        });

        positionAllMobileCards();
        mobileCarouselInitialized = true;
    }

    function cleanupMobileListeners() {
        if (!mobileCarouselInitialized || totalCards === 0) return;

        $carouselContainer?.removeEventListener('touchstart', handleTouchStart);
        $carouselContainer?.removeEventListener('touchmove', handleTouchMove);
        $carouselContainer?.removeEventListener('touchend', handleTouchEnd);

         $mobileFighterCards.forEach((card, index) => {
             const newCard = card.cloneNode(true) as HTMLElement;
             card.parentNode?.replaceChild(newCard, card);
             $mobileFighterCards[index] = newCard;
             newCard.addEventListener('click', (e) => handleMobileCardClick(e, newCard, index));
         });

        mobileCarouselInitialized = false;
    }

    function setupDesktopListeners() {
        if (desktopListenersInitialized) return;

        $desktopCardWrappers.forEach(wrapper => {
            wrapper.addEventListener('mouseenter', handleDesktopCardHover);
        });
        $desktopFightersContainer?.addEventListener('mouseleave', handleDesktopContainerExit);
        desktopListenersInitialized = true;
    }

    function cleanupDesktopListeners() {
        if (!desktopListenersInitialized) return;

        $desktopCardWrappers.forEach(wrapper => {
            wrapper.removeEventListener('mouseenter', handleDesktopCardHover);
        });
        $desktopFightersContainer?.removeEventListener('mouseleave', handleDesktopContainerExit);
        desktopListenersInitialized = false;
    }

    function setupScrollListener() {
        if (!scrollListenerActive) {
            window.addEventListener('scroll', handleScroll);
            scrollListenerActive = true;
        }
    }

    function cleanupScrollListener() {
        if (scrollListenerActive) {
            window.removeEventListener('scroll', handleScroll);
            scrollListenerActive = false;
        }
    }

    function handleResize() {
        const currentlyMobile = window.matchMedia('(max-width: 767px)').matches;

        if (currentlyMobile !== isMobileView) {
            isMobileView = currentlyMobile;

            if (isMobileView) {
                cleanupDesktopListeners();
                resetDesktopView();
                $desktopFightersContainer?.classList.add('hidden');
                $desktopFightersContainer?.classList.remove('md:flex');
                $mobileFightersContainer?.classList.remove('hidden');
                setupMobileListeners();
                setupScrollListener();
                $mobileFightersContainer?.classList.remove('hidden-by-scroll');
                 const activeCard = $carousel?.querySelector('.mobile-fighter-card.active');
                 const idToShow = activeCard?.dataset.id ?? $mobileFighterCards[0]?.dataset.id ?? null;
                 showFighterDisplay(idToShow);

            } else {
                cleanupMobileListeners();
                cleanupScrollListener();
                $mobileFightersContainer?.classList.add('hidden');
                $desktopFightersContainer?.classList.remove('hidden');
                $desktopFightersContainer?.classList.add('md:flex');
                setupDesktopListeners();
                resetDesktopView();
            }
        }
        if (isMobileView && mobileCarouselInitialized) {
             positionAllMobileCards();
        }
    }

    function initialize() {
        $fighterTextElements.forEach(el => el.classList.add('hidden', 'opacity-0'));
        $fighterImageElements.forEach(el => el.classList.add('hidden', 'opacity-0'));

        if (isMobileView) {
            $desktopFightersContainer?.classList.add('hidden');
            $mobileFightersContainer?.classList.remove('hidden');
            setupMobileListeners();
            setupScrollListener();
             const firstMobileCard = $mobileFighterCards[0];
             if(firstMobileCard) {
                 const firstId = firstMobileCard.dataset.id;
                 if(firstId) {
                    rotationAngle = 0;
                    positionAllMobileCards();
                    showFighterDisplay(firstId);
                 }
             } else {
                 showFighterDisplay(null);
             }

        } else {
            $mobileFightersContainer?.classList.add('hidden');
            $desktopFightersContainer?.classList.remove('hidden');
             $desktopFightersContainer?.classList.add('md:flex');
            setupDesktopListeners();
            showFighterDisplay(null);
        }

        window.addEventListener('resize', debounce(handleResize, 250));

        document.addEventListener('astro:before-swap', () => {
            window.removeEventListener('resize', debounce(handleResize, 250));
            cleanupMobileListeners();
            cleanupDesktopListeners();
            cleanupScrollListener();
            cancelAnimationFrame(animationFrameId!);
        }, { once: true });
    }

    initialize();
  }

  document.addEventListener('astro:page-load', heroLogic);

</script>