<div id="smoke-bkg" class="fixed top-0 -z-10 h-full w-full"></div>

<script>
	import * as THREE from "three"

	const $bkg = document.getElementById("smoke-bkg")

	let w = window.innerWidth
	let h = window.innerHeight

	const THEME = {
		dark: {
			background: 0x666666,
			light: 0xffffff,
			opacity: 1,
		},
		light: {
			background: 0xeeeeee,
			light: 0xffffff,
			opacity: 0.2,
		},
	} as const

	const themePreference = window.getThemePreference()
	let currentTheme = THEME[themePreference]

	// inicializar Three.js
	// 3 cosas b√°sicas: escena, c√°mara, renderizador

	// escena üñºÔ∏è
	const scene = new THREE.Scene()

	// camara üìπ
	// 75 -> √°ngulo de visi√≥n
	const camera = new THREE.PerspectiveCamera(75, w / h, 1, 1000)
	camera.position.z = 10
	scene.add(camera)

	// ‚ñ∂Ô∏è renderizador
	const renderer = new THREE.WebGLRenderer()
	renderer.setSize(w, h)
	// color de fondo
	renderer.setClearColor(currentTheme.background, 1)

	$bkg?.appendChild(renderer.domElement)

	// a√±adir una luz directional
	const light = new THREE.DirectionalLight(currentTheme.light, 0.5)
	// posicion de la luz
	light.position.set(-1, 3, 1)
	scene.add(light)

	const smokeParticles: THREE.Mesh[] = []

	const loader = new THREE.TextureLoader()
	loader.crossOrigin = "" // <- en localhost no pasa nada, pero si desplegamos a un servidor, puede ser necesario

	loader.load("/smoke.webp", (texture) => {
		// 1. geometria
		// crear un plano geom√©trico de 300x300
		const smokeGeo = new THREE.PlaneGeometry(300, 300)

		// 2. material
		const smokeMaterial = new THREE.MeshLambertMaterial({
			map: texture,
			transparent: true,
			opacity: currentTheme.opacity,
		})

		const NUM_OF_PARTICLES = 300
		for (let p = 0; p < NUM_OF_PARTICLES; p++) {
			// crear la malla con la geometria y el material
			const particle = new THREE.Mesh(smokeGeo, smokeMaterial)
			// posicionar aleatoriamente
			// en la x, y, z
			particle.position.set(
				Math.random() * 500 - 250, // X (de -250 a 250)
				Math.random() * 500 - 250, // Y (de -250 a 250)
				Math.random() * 1000 - 100 // Z (de -100 a 900)
			)
			// aleatoriamente la z
			particle.rotation.z = Math.random() * 360
			// a√±adimos la particula en la escena
			scene.add(particle)
			// a√±adimos la particula al array
			smokeParticles.push(particle)
		}
	})

	function resize() {
		h = window.innerHeight
		w = window.innerWidth
		camera.aspect = w / h
		camera.updateProjectionMatrix() // este metodo lo ten√©is que ejecutar siempre que cambiais los par√°metros de la c√°mara
		renderer.setSize(w, h)
	}

	function animate() {
		requestAnimationFrame(animate)

		smokeParticles.forEach((particle) => {
			particle.rotation.z += 0.001
		})

		renderer.render(scene, camera)
	}

	animate()

	// se va a disparar continuamente mientras hace el resize
	window.addEventListener("resize", resize)

	window.addEventListener("theme-changed", () => {
		const themePreference = window.getThemePreference()
		currentTheme = THEME[themePreference]
		light.color.setHex(currentTheme.light)
		renderer.setClearColor(currentTheme.background, 1)

		smokeParticles.forEach((particle) => {
			particle.material.opacity = currentTheme.opacity
		})
	})
</script>
